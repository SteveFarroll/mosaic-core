use crate::{Error, PrivateKey, PublicKey, Timestamp};
use ed25519_dalek::Signature;
use rand_core::{OsRng, RngCore};

/// A `record` is a digitally signed datum generated by a user,
/// stored in and retrieved from a server, and used by an application,
pub struct Record(Vec<u8>);

impl Record {
    /// Interpret a sequence of bytes as a `Record`. Checks validity.
    ///
    /// # Errors
    ///
    /// Returns an `Err` if the input is more than 1 MiB in length, or if
    /// any verification failed (signature, hash, or standards compliance)
    #[allow(clippy::missing_panics_doc)]
    pub fn from_bytes(bytes: &[u8]) -> Result<Record, Error> {
        if bytes.len() > 1_048_576 {
            return Err(Error::RecordTooLong);
        }
        if bytes.len() < 184 {
            return Err(Error::RecordTooShort);
        }

        let public_key = PublicKey::from_bytes(bytes[128..160].try_into().unwrap())?;

        // Compute the hash
        let mut realhash: [u8; 64] = [0; 64];
        let mut hasher = blake3::Hasher::new();
        hasher.update(&bytes[128..bytes.len()]);
        hasher.finalize_xof().fill(&mut realhash[..]);

        // Compare the hash to the claimed hash
        if realhash != bytes[64..128] {
            return Err(Error::HashMismatch);
        }

        // Verify the signature
        let sig = Signature::from_slice(&bytes[0..64])?;
        let digest = crate::crypto::Blake3 { h: hasher };
        public_key
            .0
            .verify_prehashed_strict(digest, Some(b"Mosaic"), &sig)?;

        // Verify the timestamp is valid
        let _timestamp = Timestamp::from_slice(bytes[160..166].try_into().unwrap())?;

        // Verify reserved flags are 0
        let flags = u16::from_le_bytes(bytes[180..181].try_into().unwrap());
        if flags & 0xFFE0 != 0 {
            return Err(Error::ReservedFlagsUsed);
        }

        // Verify reserved space is 0
        if bytes[182] | bytes[183] != 0 {
            return Err(Error::ReservedSpaceUsed);
        }

        Ok(Record(bytes.to_owned()))
    }

    /// View a `Record` as a slice of bytes
    #[must_use]
    pub fn as_bytes(&self) -> &[u8] {
        &self.0
    }

    /// Create a new `Record` from component parts,
    /// at the current time, with a new address.
    ///
    /// # Errors
    ///
    /// Returns an `Err` if any data is too long, if reserved flags are set,
    /// or if signing fails.
    #[allow(clippy::missing_panics_doc)]
    pub fn new(
        master_public_key: PublicKey,
        signing_private_key: &PrivateKey,
        application_id: u32,
        tag_bytes: &[u8],
        payload: &[u8],
        flags: u16,
    ) -> Result<Record, Error> {
        if payload.len() > 524_288 {
            return Err(Error::RecordTooLong);
        }
        if tag_bytes.len() > 524_288 {
            return Err(Error::RecordTooLong);
        }

        let len = 216 + tag_bytes.len() + payload.len();
        if len > 1_048_576 {
            return Err(Error::RecordTooLong);
        }

        if flags & 0xFFE0 != 0 {
            return Err(Error::ReservedFlagsUsed);
        }

        let mut bytes = vec![0; len];

        let tag_end = 216 + tag_bytes.len();

        bytes[tag_end..len].copy_from_slice(payload);

        bytes[216..tag_end].copy_from_slice(tag_bytes);

        bytes[212..214].copy_from_slice(flags.to_le_bytes().as_slice());

        bytes[210..212].copy_from_slice(((payload.len() / 8) as u16).to_le_bytes().as_slice());

        bytes[208..210].copy_from_slice(((tag_bytes.len() / 8) as u16).to_le_bytes().as_slice());

        bytes[204..208].copy_from_slice(application_id.to_le_bytes().as_slice());

        let mut nonce: [u8; 6] = [0; 6];
        OsRng.fill_bytes(&mut nonce);
        bytes[198..204].copy_from_slice(nonce.as_slice());

        let timestamp = Timestamp::now().unwrap();
        bytes[192..198].copy_from_slice(timestamp.to_slice().as_slice());

        bytes[160..192].copy_from_slice(master_public_key.as_bytes().as_slice());

        let public_key = signing_private_key.public();
        bytes[128..160].copy_from_slice(public_key.as_bytes().as_slice());

        let mut hasher = blake3::Hasher::new();
        hasher.update(&bytes[128..len]);
        hasher.finalize_xof().fill(&mut bytes[64..128]);

        let digest = crate::crypto::Blake3 { h: hasher };
        let sig = signing_private_key
            .0
            .sign_prehashed(digest, Some(b"Mosaic"))?;
        bytes[0..64].copy_from_slice(sig.to_bytes().as_slice());

        Ok(Record(bytes))
    }
}
