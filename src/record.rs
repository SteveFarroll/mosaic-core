use crate::{Error, PrivateKey, PublicKey, Timestamp};
use rand_core::{RngCore, OsRng};

/// A `record` is a digitally signed datum generated by a user,
/// stored in and retrieved from a server, and used by an application,
pub struct Record(Vec<u8>);

impl Record {
    /// Interpret a sequence of bytes as a `Record`. Checks validity.
    ///
    /// # Errors
    ///
    /// Returns an `Err` if the input is more than 1 MiB in length
    pub fn from_bytes(bytes: &[u8]) -> Result<Record, Error> {
        if bytes.len() > 1_048_576 {
            return Err(Error::RecordTooLong);
        }

        unimplemented!()
    }

    /// View a `Record` as a slice of bytes
    pub fn as_bytes(&self) -> &[u8] {
        &self.0
    }

    /// Create a new `Record` from component parts,
    /// at the current time, with a new address.
    pub fn new(
        master_public_key: PublicKey,
        signing_private_key: PrivateKey,
        application_id: u32,
        tag_bytes: &[u8],
        payload: &[u8],
        flags: u16,
    ) -> Result<Record, Error> {
        if payload.len() > 524_288 {
            return Err(Error::RecordTooLong);
        }
        if tag_bytes.len() > 524_288 {
            return Err(Error::RecordTooLong);
        }

        let len = 184 + tag_bytes.len() + payload.len();
        if len > 1_048_576 {
            return Err(Error::RecordTooLong);
        }

        let mut bytes = Vec::with_capacity(len);
        bytes.resize(len, 0);

        let tag_end = 184 + tag_bytes.len();

        bytes[tag_end..len].copy_from_slice(payload);

        bytes[184..tag_end].copy_from_slice(tag_bytes);

        bytes[180..182].copy_from_slice(flags.to_le_bytes().as_slice());

        bytes[178..180].copy_from_slice(
            ((payload.len() / 8) as u16).to_le_bytes().as_slice());

        bytes[176..178].copy_from_slice(
            ((tag_bytes.len() / 8) as u16).to_le_bytes().as_slice());

        bytes[172..176].copy_from_slice(application_id.to_le_bytes().as_slice());

        let mut nonce: [u8; 6] = [0; 6];
        OsRng.fill_bytes(&mut nonce);
        bytes[166..172].copy_from_slice(nonce.as_slice());

        let timestamp = Timestamp::now().unwrap();
        bytes[160..166].copy_from_slice(timestamp.to_slice().as_slice());

        bytes[128..160].copy_from_slice(master_public_key.as_bytes().as_slice());

        let public_key = signing_private_key.public();
        bytes[96..128].copy_from_slice(public_key.as_bytes().as_slice());

        let mut hasher = blake3::Hasher::new();
        hasher.update(&bytes[96..len]);
        let hash = hasher.finalize();

        bytes[64..96].copy_from_slice(hash.as_bytes().as_slice());

        use ed25519_dalek::Signer;
        let sig = signing_private_key.0.sign(&bytes[64..128]);
        bytes[0..64].copy_from_slice(sig.to_bytes().as_slice());

        Ok(Record(bytes))
    }
}
