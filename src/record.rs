use crate::{Error, PrivateKey, PublicKey, Timestamp};
use ed25519_dalek::Signature;
use rand_core::{OsRng, RngCore};

/// A `record` is a digitally signed datum generated by a user,
/// stored in and retrieved from a server, and used by an application,
//
// INVARIANTS:
//   at least 216 bytes long
//   no more than 1048576 bytes long
//   hash is correct
//   signature is correct
//   reserved flags are zero
//   reserved areas are zero
//   216 + len_t*8 + len_p*8 == self.0.len()
pub struct Record(Vec<u8>);

impl Record {
    /// Interpret a sequence of bytes as a `Record`. Checks validity.
    ///
    /// # Errors
    ///
    /// Returns an `Err` if any verification fails. See `verify()`
    pub fn from_bytes(bytes: &[u8]) -> Result<Record, Error> {
        let unverified = Record(bytes.to_vec());
        unverified.verify()?;
        Ok(unverified)
    }

    /// Interpret a vector of bytes as a `Record`. Checks validity.
    ///
    /// # Errors
    ///
    /// Returns an `Err` if any verification fails. See `verify()`
    pub fn from_vec(vec: Vec<u8>) -> Result<Record, Error> {
        let unverified = Record(vec);
        unverified.verify()?;
        Ok(unverified)
    }

    /// Verify invariants
    ///
    /// # Errors
    ///
    /// Returns an `Err` if the length is too short (<216) too long (>1048576),
    /// if the sum of the sections (header, tags, and payload) doesn't equal the
    /// length, if either public key is invalid, if the hash is wrong, if the
    /// signature is wrong, if the timestamp is out of range, or if any reserved
    /// area is not zeroed.
    #[allow(clippy::missing_panics_doc)]
    pub fn verify(&self) -> Result<(), Error> {
        // Verify all lengths
        if self.0.len() > 1_048_576 {
            return Err(Error::RecordTooLong);
        }
        if self.0.len() < 216 {
            return Err(Error::RecordTooShort);
        }
        if 216 + self.tags_len() + self.payload_len() != self.0.len() {
            return Err(Error::RecordSectionLengthMismatch);
        }

        // Verify PublicKey validity
        let signing_public_key = PublicKey::from_bytes(self.0[128..160].try_into().unwrap())?;
        let _author_public_key = PublicKey::from_bytes(self.0[160..192].try_into().unwrap())?;

        // Compute the true hash
        let mut truehash: [u8; 64] = [0; 64];
        let mut hasher = blake3::Hasher::new();
        hasher.update(&self.0[128..self.0.len()]);
        hasher.finalize_xof().fill(&mut truehash[..]);

        // Compare the true hash to the claimed hash
        if truehash != self.0[64..128] {
            return Err(Error::HashMismatch);
        }

        // Verify the signature
        let signature = Signature::from_slice(&self.0[0..64])?;
        let digest = crate::crypto::Blake3 { h: hasher };
        signing_public_key
            .0
            .verify_prehashed_strict(digest, Some(b"Mosaic"), &signature)?;

        // Verify the timestamp
        let _timestamp = Timestamp::from_slice(self.0[160..166].try_into().unwrap())?;

        // Verify reserved flags are 0
        let flags = self.flags();
        if flags & 0xFFE0 != 0 {
            return Err(Error::ReservedFlagsUsed);
        }

        // Verify reserved space is 0
        if self.0[182] | self.0[183] != 0 {
            return Err(Error::ReservedSpaceUsed);
        }

        Ok(())
    }

    /// Create a new `Record` from component parts,
    /// at the current time, with a new address.
    ///
    /// # Errors
    ///
    /// Returns an `Err` if any data is too long, if reserved flags are set,
    /// or if signing fails.
    #[allow(clippy::missing_panics_doc)]
    pub fn new(
        master_public_key: PublicKey,
        signing_private_key: &PrivateKey,
        application_id: u32,
        tag_bytes: &[u8],
        payload: &[u8],
        flags: u16,
    ) -> Result<Record, Error> {
        if payload.len() > 524_288 {
            return Err(Error::RecordTooLong);
        }
        if tag_bytes.len() > 524_288 {
            return Err(Error::RecordTooLong);
        }

        let len = 216 + tag_bytes.len() + payload.len();
        if len > 1_048_576 {
            return Err(Error::RecordTooLong);
        }

        if flags & 0xFFE0 != 0 {
            return Err(Error::ReservedFlagsUsed);
        }

        let mut bytes = vec![0; len];

        let tag_end = 216 + tag_bytes.len();

        bytes[tag_end..len].copy_from_slice(payload);

        bytes[216..tag_end].copy_from_slice(tag_bytes);

        bytes[212..214].copy_from_slice(flags.to_le_bytes().as_slice());

        #[allow(clippy::cast_possible_truncation)]
        bytes[210..212].copy_from_slice(((payload.len() / 8) as u16).to_le_bytes().as_slice());

        #[allow(clippy::cast_possible_truncation)]
        bytes[208..210].copy_from_slice(((tag_bytes.len() / 8) as u16).to_le_bytes().as_slice());

        bytes[204..208].copy_from_slice(application_id.to_le_bytes().as_slice());

        let mut nonce: [u8; 6] = [0; 6];
        OsRng.fill_bytes(&mut nonce);
        bytes[198..204].copy_from_slice(nonce.as_slice());

        let timestamp = Timestamp::now().unwrap();
        bytes[192..198].copy_from_slice(timestamp.to_slice().as_slice());

        bytes[160..192].copy_from_slice(master_public_key.as_bytes().as_slice());

        let public_key = signing_private_key.public();
        bytes[128..160].copy_from_slice(public_key.as_bytes().as_slice());

        let mut hasher = blake3::Hasher::new();
        hasher.update(&bytes[128..len]);
        hasher.finalize_xof().fill(&mut bytes[64..128]);

        let digest = crate::crypto::Blake3 { h: hasher };
        let sig = signing_private_key
            .0
            .sign_prehashed(digest, Some(b"Mosaic"))?;
        bytes[0..64].copy_from_slice(sig.to_bytes().as_slice());

        let record = Record(bytes);

        if cfg!(debug_assertions) {
            record.verify()?;
        }

        Ok(record)
    }

    /// View a `Record` as a slice of bytes
    #[must_use]
    pub fn as_bytes(&self) -> &[u8] {
        &self.0
    }

    /// Signature
    #[allow(clippy::missing_panics_doc)]
    #[must_use]
    pub fn signature(&self) -> Signature {
        Signature::from_slice(&self.0[0..64]).unwrap()
    }

    /// Hash
    #[allow(clippy::missing_panics_doc)]
    #[must_use]
    pub fn hash(&self) -> &[u8; 64] {
        self.0[64..128].try_into().unwrap()
    }

    /// Signing `PublicKey`
    #[allow(clippy::missing_panics_doc)]
    #[must_use]
    pub fn signing_public_key(&self) -> PublicKey {
        PublicKey::from_bytes(self.0[128..160].try_into().unwrap()).unwrap()
    }

    /// Author `PublicKey`
    #[allow(clippy::missing_panics_doc)]
    #[must_use]
    pub fn author_public_key(&self) -> PublicKey {
        PublicKey::from_bytes(self.0[160..192].try_into().unwrap()).unwrap()
    }

    /// Timestamp
    #[allow(clippy::missing_panics_doc)]
    #[must_use]
    pub fn timestamp(&self) -> Timestamp {
        Timestamp::from_slice(self.0[160..166].try_into().unwrap()).unwrap()
    }

    /// Application ID
    #[allow(clippy::missing_panics_doc)]
    #[must_use]
    pub fn application_id(&self) -> u32 {
        u32::from_le_bytes(self.0[204..208].try_into().unwrap())
    }

    /// Address
    #[allow(clippy::missing_panics_doc)]
    #[must_use]
    pub fn address(&self) -> &[u8; 48] {
        self.0[160..208].try_into().unwrap()
    }

    /// Flags
    #[allow(clippy::missing_panics_doc)]
    #[must_use]
    pub fn flags(&self) -> u16 {
        u16::from_le_bytes(self.0[180..181].try_into().unwrap())
    }

    /// Tags length
    #[allow(clippy::missing_panics_doc)]
    #[must_use]
    pub fn tags_len(&self) -> usize {
        let len_t = u16::from_le_bytes(self.0[208..210].try_into().unwrap()) as usize;
        len_t * 8
    }

    /// Tag bytes
    #[must_use]
    pub fn tags_bytes(&self) -> &[u8] {
        &self.0[216..216 + self.tags_len()]
    }

    /// Payload length
    #[allow(clippy::missing_panics_doc)]
    #[must_use]
    pub fn payload_len(&self) -> usize {
        let len_p = u16::from_le_bytes(self.0[210..212].try_into().unwrap()) as usize;
        len_p * 8
    }

    /// Payload bytes
    #[must_use]
    pub fn payload_bytes(&self) -> &[u8] {
        &self.0[216 + self.tags_len()..]
    }
}
